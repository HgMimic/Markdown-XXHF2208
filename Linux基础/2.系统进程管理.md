# 系统进程管理

## 进程概述

进程是已启动的可执行程序的运行实例，进程有以下组成部分：

- 已分配内存的地址空间
- 进程 ID
- 程序的代码
- 进程状态

进程管理包括进程调度、中断处理、信号、进程优先级、进程切换、进程状态、进程内存等。

### 进程的生命周期

![进程的生命周期](.\Linux基础.assets\进程的生命周期.png)

描述如下：

- 父进程复制(fork)自己的地址空间创建一个新的（子）进程结构。
- 每个新进程分配一个唯一的 PID，满足跟踪安全性之需。
- PID 和 PPID（父进程 ID）是子进程环境的元素，任何进程都可以创建子进程。
- 所有进程都是第一个系统进程的后代
  > CentOS 5 或 6，PID 为 1 的进程是 `init`  
  > CentOS 7，PID 为 1 的进程是 `systemd`

### 僵尸进程：不执行代码，占用内存地址空间

- 当一个进程接收到终止信号时，它结束之前需要一段时间来结束所有任务。在进程执行所有代码之后，它将相关终止报告发给父进程。
- 父进程正常情况下会移除所有子进程的数据结构。如果父进程没能接收子进程退出信号，那么子进程变为僵尸进程。所以通常在很短的某个时刻内它是一个僵尸进程。
- 使用 `kill` 命令是不能杀死僵尸进程的，因为它已经被认定死亡了。可以尝试 `kill` 僵尸进程的父进程，僵尸进程会随之消失。
- 如果一个进程为僵尸状态，父进程是 `init` 或 `systemd` ，那么需要重启系统来解决问题。

> 子进程结束，向父进程发送信号之后；父进程收到信号，做出响应释放其所占用的资源之前。子进程此时为 zombie 状态。

### 线程

- 线程是进程中产生的一个执行单元，在同一进程中与其他线程并行运行。
- 线程之间可以共享资源，比如内存、地址空间、打开文件等。

### 上下文切换

- 在处理器执行期间，运行进程的信息被存储在处理器的寄存器和高速缓存中，执行的进程被加载到寄存器的数据称为上下文。
- 在实际处理器运行过程中，先存储运行进程的上下文，然后将下一个要运行的进程上下文恢复到存储器，这个过程称之为上下文切换。
- 一般不能有太多上下文切换，因为处理器每次要刷新寄存器和高速缓存，以便释放空间给新进程，可能导致性能下降。

### 中断处理

- 中断是优先级最高的任务之一，通常由 I/O 产生，比如网络接口，键盘，磁盘控制器等。
- 当一个中断信号到达内核的时候，内核必须从当前执行的进程切换到一个新的进程，以便处理这个中断。
- 中断会导致上下文切换，也就是说大量中断会导致性能下降。
  > **注意**：在 Linux 当中有两种类型的中断，软中断和硬中断。  
  > 硬中断是由硬件产生的，需要快速响应（如磁盘 IO 中断、键盘中断、鼠标中断等）。  
  > 软中断被用来处理可以推迟的任务（TCP/IP、SCSI 协议操作等）。

## 进程的属性

- 进程 ID(PID)：是唯一的数值，且除了系统进程 1，每次随机
- 父进程的 ID(PPID)
- 启动进程的用户 ID(UID)和所归属的组(GID)
- 进程状态：状态分为运行 `R` 、休眠 `S` 、僵尸 `Z`
- 进程执行的优先级
- 进程所连接的终端名
- 进程资源占用：如占用资源大小（内存、CPU 占用量）

## `ps` 命令：查看进程

- **`ps aux`** 查看进程信息

> `-a`或`a` 显示跟当前终端关联的所有进程  
> `-u`或`u` 基于用户的格式显示  
> `-x`或`x` 显示所有进程，不以终端区分

**包含信息如下**：

| USER | PID     | %CPU            | %MEM           | VSZ                    | RSS                    | TTY      | STAT         | START            | TIME                    | COMMAND        |
| ---- | ------- | --------------- | -------------- | ---------------------- | ---------------------- | -------- | ------------ | ---------------- | ----------------------- | -------------- |
| 用户 | 进程 ID | 占用 CPU 百分比 | 占用内存百分比 | 占用虚拟内存大小（KB） | 占用物理内存大小（KB） | 运行终端 | 当前运行状态 | 被触发启动的时间 | 实际使用 CPU 运作的时间 | 实际执行的指令 |
| root | 7045    | 0.0             | 0.0            | 155360                 | 1872                   | tty1     | R+           | 19:13            | 0:00                    | ps aux         |

**注**：执行指令使用 `[]` 方括号括起来的进程是内核态的进程，没有括起来的是用户态进程

> **Linux 进程有五种基本状态**：
>
> - `R` 该程序目前正在运行，或者可被运行（正在使用 CPU 资源）
> - `S` 该程序目前正在睡眠，可被某些信号唤醒（正在等待 CPU 资源）
> - `T` 该程序目前是停止状态（ `Ctrl+z` 指令可以发送停止信号）
> - `Z` 该程序应该已经终止，但是其父程序没有正常终止它
> - `D` 不可中断状态（不可被唤醒的睡眠状态），通常存在于 I/O 情况下
>
> **基本状态后追加的状态**：
>
> - `<` 表示进程运行在高优先级上
> - `N` 表示进程运行在低优先级上
> - `L` 表示进程有页面锁定在内存中
> - `s` 表示进程是控制进程
> - `l` 表示进程是多线程的
> - `+` 表示当前进程运行在前台

`Ctrl+c` 发送 SIGINT 信号，终止进程。  
`Ctrl+z` 发送 SIGSTOP 信号，挂起进程，将作业放置到后台（暂停）。  
`Ctrl+d` 不是发送信号，而是表示一个特殊的二进制值，表示`EOF`，代表输入完成或者注销。

**例 1**：查看进程状态  
`vim a.txt` 使用 vim 打开文件，处于交互状态  
`ps aux | grep a.txt` 查看 vim 进程处于 S+状态  
`Ctrl+z` 使 vim 进入停止状态  
`ps aux | grep a.txt` 查看 vim 进程处于 T 状态

**例 2**：不可中断状态  
`tar -zcvf usr-tar.gz` 压缩打包一个文件  
`ps aux | grep usr-tar.gz` 不断查看状态，由 S+、R+，变为 D+，表示 tar 正在进行 I/O 操作，当前不可中断

- **`ps -ef`** 查看进程信息

> `-e` 显示所有进程  
> `-f` 显示完整格式输出

**包含信息如下**：
| UID | PID | PPID | C | STIME | TTY | TIME | CMD |
| -------------- | ------ | -------- | --------- | -------------------- | -------- | ------------------------- | -------------- |
| 进程所属用户 ID | 进程 ID | 父进程 ID | CPU 利用率 | 进程启动时的系统时间 | 运行终端 | 运行进程累计占用 CPU 的时间 | 启动的程序名称 |

**例**：测试 CPU 使用时间  
`dd if=/dev/zero of=/a.txt count=10 bs=100` 进行 dd  
`ps -ef | grep dd` 持续观察 dd 运行状态中 CPU 使用时间的间歇性变化

## `top` 命令：监听进程

top 命令用于动态持续监听进程的运行状态，并且查看系统状态

`top [选项]`

> `-d <秒数>` 指定 top 命令每隔几秒更新，默认 3s  
> `-b` 使用批处理模式输出，一般与`-n`合用，用于将输出重定向到文件中  
> `-n <次数>` 指定 top 命令执行的次数  
> `-p <PID>` 只查看某个 PID 对应的进程
> `-u <用户名>` 只查看某个用户的进程  
> `-s` 在安全模式运行，避免在交互模式出现错误

在 `top` 命令的交互模式中可以执行的命令：

> `?` 或 `h` 显示帮助  
> `P` 按照 CPU 使用率降序  
> `M` 按照内存使用率降序  
> `T` 按照 CPU 累计运行时间 TIME+降序  
> `N` 按照 PID 降序  
> `k` PID 指定进程发送指定信号  
> `r` PID 指定进程重设优先级（Nice 值）  
> `q` 退出 top 命令

**`top` 命令的输出信息**

| top - 11:23:25 | up 1:27      | 1 user           | load average: 0.00, 0.02, 0.05       |
| -------------- | ------------ | ---------------- | ------------------------------------ |
| 系统当前时间   | 系统运行时间 | 当前登录用户数量 | 系统 1、5、15 分钟之前的任务队列长度 |

> 任务队列长度即是当前排队等待占用 CPU 资源的进程总数，建议 1 分钟每个核心任务队列长度不大于 3。

| Tasks: 109 total | 2 running      | 107 sleeping   | 0 stopped      | 0 zombie       |
| ---------------- | -------------- | -------------- | -------------- | -------------- |
| 总进程数         | R 状态的进程数 | S 状态的进程数 | T 状态的进程数 | Z 状态的进程数 |

| %Cpu(s)    | 0.0 us       | 0.2 sy               | 0.0 ni               | 99.8 id  | 0.0 wa              | 0.0 hi     | 0.0 si     | 0.0 st                   |
| ---------- | ------------ | -------------------- | -------------------- | -------- | ------------------- | ---------- | ---------- | ------------------------ |
| CPU 占用率 | 用户进程占用 | 系统（内核）进程占用 | 变更优先级的进程占用 | 空闲占用 | 等待 I/O 的进程占用 | 硬中断占用 | 软中断占用 | 虚拟机（偷取 steal）占用 |

| KiB Mem : 2028116 total | 1388812 free   | 171412 used      | 467892 buff/cache         | KiB Swap: 2097148 total | 2096884 free   | 264 used         | 1658056 avail Mem |
| ----------------------- | -------------- | ---------------- | ------------------------- | ----------------------- | -------------- | ---------------- | ----------------- |
| 物理内存总量（KB）      | 空闲物理内存量 | 使用的物理内存量 | 用作缓冲/缓存的物理内存量 | 虚拟内存总量（KB）      | 空闲虚拟内存量 | 使用的虚拟内存量 | 可用物理内存量    |

> 四五行内容和 `free` 命令返回结果相同。  
> 缓存(Cache)和缓冲(Buffer)的区别：
>
> - 缓存是在**读取**硬盘数据时，把最常用的数据保存在**内存缓存区**内，下次使用直接从缓存区读取，加快读取速度。
> - 缓冲是在向硬盘**写入**数据时，先把数据放入**内存缓冲区**内，再一起集中写入硬盘，减少写入硬盘次数，减少磁盘碎片和硬盘反复寻道，从而提高系统性能。
>
> _简单来说，缓存是用来加速数据从硬盘中读取的，缓冲是用来加速数据写入硬盘中的。_

| PID     | USER       | PR                   | NI               | VIRT         | RES          | SHR          | S        | %CPU           | %MEM               | TIME+             | COMMAND    |
| ------- | ---------- | -------------------- | ---------------- | ------------ | ------------ | ------------ | -------- | -------------- | ------------------ | ----------------- | ---------- |
| 进程 ID | 进程所有者 | 内核动态调整的优先级 | 进程优先级(Nice) | 虚拟内存用量 | 物理内存用量 | 共享内存用量 | 进程状态 | CPU 占用百分比 | 物理内存占用百分比 | 累计占用 CPU 时间 | 执行的命令 |

> PR 优先级由系统决定，用户不能修改；`rt`表示进程在实时优先级下运行。  
> NI 优先级可由用户调整，数值在-20~19 之间  
> 两个优先级都是数字越小优先级越高

## `kill`、`killall`、`pkill` 命令：向进程发送信号

### `kill` 命令

`kill [SIG] PID` kill 只能识别 PID，不能识别进程名

> `kill -l` 或 `man 7 signal` 可以列出进程信号

**常用信号：**

| 编号 | 信号名  | 信号含义                                                                                              |
| ---- | ------- | ----------------------------------------------------------------------------------------------------- |
| 1    | SIGHUP  | 立即关闭，重新读取配置文件之后重启                                                                    |
| 2    | SIGINT  | 进程终止信号，用于终止前台进程，相当于输入`Ctrl+c`                                                    |
| 3    | SIGQUIT | 退出                                                                                                  |
| 8    | SIGFPE  | 进程的算术运算致命错误时发出，包括浮点运算错误、溢出、除数为 0 等                                     |
| 9    | SIGKILL | 用来立即结束进程的运行，该信号不能被阻塞、处理和忽略，一般用于强制中止进程                            |
| 15   | SIGTERM | 正常结束进程的信号，`kill`命令的默认信号，若进程出现问题无法正常结束，需要使用(9)SIGKILL 强制结束进程 |
| 18   | SIGCONT | 让暂停的进程恢复执行(从 T 恢复为 R 或 S 等状态)，该信号不能被阻断                                     |
| 19   | SIGSTOP | 停止前台进程（进程状态变为 T），相当于输入`Ctrl+z`                                                    |
| 20   | SIGTSTP | 暂停前台进程（较为温和的停止）                                                                        |

### `killall` 命令

`killall [选项] [信号] 进程名` 通过进程名发送信号

> `-i` 交互式询问是否要杀死某个进程  
> `-I` 忽略进程名大小写

### `pkill` 命令

`pkill [选项] [信号] 进程名` 通过进程名发送信号

> `-t` 按照终端号踢出用户  
> **例子**：`pkill -9 -t pts/1` 将 pts/1 中断登录的进程强制中止

## 进程优先级

进程优先级由两个值构成：PRI 值和 NI 值，两个值数值越小，代表进程优先级越高

- PRI 值代表 Priority，由内核动态调整，用户不能直接修改
- NI 值代表 Nice，可以由用户调整
  - 范围是-20~19。
  - 普通用户调整范围是 0~19，且只能调整自己的进程。
  - 普通用户只能调高 Nice 值，而不能调低。
  - 只有 root 用户有权随意修改任何用户的进程 Nice 值。

### `nice` 命令：修改新执行命令的 NI 值

`nice [选项] 命令完整路径`

> `-n <NI值>` 给命令赋予 NI 值  
> 例：`nice -n -5 /usr/sbin/httpd` 修改 http 服务进程的 NI 值为-5。_启动时需要使用 httpd 路径启动，而非服务启动。_

### `renice` 命令：修改已经存在进程的 NI 值

`renice [选项] PID`

> `-n <NI值>` 给进程赋予 NI 值  
> 例：`renice -n -10 1822` 给 PID 为 1822 的进程重设 Nice 值

## 进程工作状态管理

**Linux 进程常见工作状态：**

- 前台进程：在终端前台运行的命令，命令执行中持续占用前台。
- 依赖终端：终端作为进程的控制终端，一旦终端关闭，进程也随之消失。
- 后台进程：进程放入后台运行，通常不会影响当前终端后续命令执行。用户可以使用 `CMD &` 将命令放入后台运行，或者使用系统定时任务，执行时其将不依赖登录终端。
- 后台运行并脱离终端：通常是守护进程(Daemon)，用户可以使用 `nohup CMD &` 将命令放入后台且脱离终端。

工作状态相关操作

- `&` 用在一个命令最后，可以把这个命令放到后台执行。
- `Ctrl+z` 将一个正在前台执行的命令放到后台，并且暂停。
- `jobs` 查看当前有多少后台运行的进程，是一个作业控制命令。
- `fg` 将 T 状态进程恢复到前台运行，多个后台进程可以指定其 `jobs` 查到的序号。
- `bg` 将 T 状态进程恢复到后台运行，多个后台进程可以指定其 `jobs` 查到的序号。

## `screen` 命令：操作会话窗口

screen 中有会话的概念，用户可以在一个 screen 会话中创建多个 screen 窗口，在每一个 screen 窗口中就像操作一个真实的 Telnet/SSH 连接窗口一样。

> `screen` 命令默认未安装，需要手动安装。

- `screen [CMD]` 创建一个新的 screen 终端窗口，如果 screen 后面直接键入命令则 screen 在命令执行结束后自动销毁。
- `screen -d` 可以从 screen 窗口退出到初始终端(detached 分离)，在 screen 窗口中使用`Ctrl+a+d`有同样效果。
- `screen -ls` 列出当前所有会话，以 `PID.tty.host` 格式显示名称（自定义名称除外），用**分离**`detached`和**归属**`attached`表示状态。
- `screen -r <PID.tty.host|会话名>` 回到指定的 screen 会话。
- `screen -S <会话名> [CMD]` 新建指定会话名的会话。

> 每个 screen 会话互相独立，命令终端占用一个 pts/n 远程终端。这样使得 screen 会话不依赖初始终端，而且可以在任意终端恢复本用户的 screen 会话。

## `lsof` 命令：列出进程调用或打开的文件信息

`lsof [选项]` 用于查看进程调用或打开的文件，以及进程打开的端口(TCP、UDP)

> `-i <条件>` 列出符合条件的进程，条件包括：`4` (IPv4) | `6` (IPv6) | `协议` (TCP|UDP) | `:端口` | `@IP`  
> `-p <进程号>` 列出指定进程调用或打开的文件信息
>
> **FD**：文件描述符，内核用于管理已被打开的文件创建的索引，用来指向被打开的文件。

## `ss` 命令：查看套接字(Socket)

`ss [选项]`

> `-a` 显示监听和建立连接的套接字  
> `-t` 仅显示 TCP 套接字  
> `-u` 仅显示 UDP 套接字  
> `-n` 以端口号显示（默认显示服务名称）  
> `-p` 显示使用套接字的进程
